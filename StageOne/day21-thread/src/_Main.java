/**
 * <table>
 * <caption>day21: 多线程<caption/>
 * <tr></tr>
 * <tr><th>source code</th>
 *     <th>Description</th></tr>
 *
 * <tr><td><code>AtomicTest</code></td>
 *     <td>证明 volatile 不具备原子性</td></tr>
 *
 * <tr><td><code>CasTest</code></td>
 *     <td>模仿 CAS 核心思想，来弥补 volatile 的无原子性<td/></tr>
 *
 * <tr><td><code>AtomicIntegerTest</code></td>
 *     <td>原子类 AtomicInteger 的使用<td/></tr>
 *
 * <tr><td><code>ThreadPoolTest</code></td>
 *     <td>线程池的使用<td/></tr>
 *
 * <tr></tr>
 *
 * <tr><th>( pakage customized_thread_pool )</th></tr>
 *
 * <tr><td><code>MyHandler</code></td>
 *     <td>自定义一个简单的 拒绝策略<td/></tr>
 *
 * <tr><td><code>MyThreadFactory</code></td>
 *     <td>自定义一个简单的 线程工厂<td/></tr>
 *
 * <tr><td><code>MyThreadPool</code></td>
 *     <td>自定义一个线程池<td/></tr>
 *
 * <tr><td><code>Test</code></td>
 *     <td>测试 自定义线程池<td/></tr>
 *
 * <tr></tr>
 *
 * <tr><th>( pakage thread_synchronizer )</th></tr>
 *
 * <tr><td><code>CountDownLatch_Test</code></td>
 *     <td>CountDownLatch 线程同步器的使用<td/></tr>
 *
 * <tr><td><code>CyclicBarrier_Test</code></td>
 *     <td>CyclicBarrier 线程同步器的使用<td/></tr>
 *
 * <tr><td><code>Semaphore_Test</code></td>
 *     <td>Semaphore 线程同步器的使用<td/></tr>
 *
 *
 * <tr></tr>
 *
 * <tr><td><code>Singleton</code></td>
 *     <td>解决 单例设计模式 的 懒汉模式 的 "线程不安全" 问题<td/></tr>
 *
 * <table/>

 */
public class _Main {
}
