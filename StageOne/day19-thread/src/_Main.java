/**
 * <table>
 * <caption>day19：多线程<caption/>
 * <tr><tr/>
 * <tr><th>source code</th><th>Description</th></tr>
 * <tr><th>package create_thread</th></tr>
 *
 * <tr><td><code>CreateThread.Mode1.java</code></td>
 *     <td> 方式一: 通过继承 java.lang.Thread 的方式创建线程</td></tr>
 *
 * <tr><td><code>CreateThread.Mode2.java</code></td>
 *     <td> 方式二: 通过实现 Runnable 接口的方式创建线程<td/></tr>
 *
 * <tr><td><code>CreateThread.Mode3.java</code></td>
 *     <td> 方式三: 通过 方式二 的简化形式 创建线程<td/></tr>
 *
 * <tr><td><code>CreateThread.Mode4.java</code></td>
 *     <td> 方式四: 创建一个有返回值的线程<td/></tr>
 *
 * <tr><td><code>CreateThread.ThreadApplyExample.java</code></td>
 *     <td> 多线程的案例: 把一个任务拆分给多个线程来完成<td/></tr>
 *
 * <tr></tr>
 *
 * <tr><td><code>GuardThreadTest.java</code></td>
 *     <td> 守护线程的案例<td/></tr>
 *
 * <tr><td><code>JoinTest.java</code></td>
 *     <td> 线程实例方法 join() 的使用<td/></tr>
 *
 * <tr></tr>
 *
 * <tr><th>package thread_safe</th></tr>
 *
 * <tr><td><code>thread_safe.Test1.java</code></td>
 *     <td> 多线程下 【指令重排】 的问题<td/></tr>
 *
 * <tr><td><code>thread_safe.Test2.java</code></td>
 *     <td> 多线程下的 【可见性】 问题<td/></tr>
 *
 * <tr><td><code>thread_safe.Test3.java</code></td>
 *     <td> 多线程下的 【线程争抢】 问题<td/></tr>
 *
 * <tr><td><code>thread_safe.Ticket.java</code></td>
 *     <td> 运用 【同步代码块】 解决多线程下的 “线程争抢” 问题<td/></tr>
 *
 * <tr><td><code>thread_safe.Test4.java</code></td>
 *     <td> 线程安全实现方案之：【无同步方案】 案例<td/></tr>
 * <table/>
 */
public class _Main {}
